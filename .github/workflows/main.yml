# 从 byJoey/cfnew 拉取并更新为 _worker.js；每天 00:00 UTC 运行，支持手动触发
name: Update worker from byJoey/cfnew

on:
  schedule:
    - cron: '0 0 * * *'    # 每天 00:00 UTC
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  update-worker:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch upstream file into new_worker.js
        run: |
          set -euo pipefail

          UPSTREAM_OWNER="byJoey"
          UPSTREAM_REPO="cfnew"
          UPSTREAM_REF="main"
          UPSTREAM_PATH="少年你相信光吗"   # 上游仓库里的原始文件路径（保留 Unicode 名称）
          OUTFILE="new_worker.js"

          # 方案 A: 尝试使用 raw.githubusercontent.com（先不转义）
          RAW_URL="https://raw.githubusercontent.com/${UPSTREAM_OWNER}/${UPSTREAM_REPO}/${UPSTREAM_REF}/${UPSTREAM_PATH}"
          echo "Trying RAW URL: $RAW_URL"
          if curl -fsSL "$RAW_URL" -o "$OUTFILE"; then
            echo "Downloaded via RAW URL"
            exit 0
          fi

          # 方案 B: 使用 URL-encoding 的 RAW URL（Python 写法）
          ENC_URL=$(python3 - <<'PY'
import urllib.parse
print("https://raw.githubusercontent.com/{}/{}/{}"
      .format("byJoey","cfnew","main") + "/" + urllib.parse.quote("少年你相信光吗"))
PY
)
          echo "Trying encoded RAW URL: $ENC_URL"
          if curl -fsSL "$ENC_URL" -o "$OUTFILE"; then
            echo "Downloaded via encoded RAW URL"
            exit 0
          fi

          # 方案 C: 直接用 git show 读取 upstream 仓库的文件内容（通过远程引用）
          # 先添加临时 remote（如果必要）
          if ! git remote | grep -q upstream; then
            git remote add upstream "https://github.com/${UPSTREAM_OWNER}/${UPSTREAM_REPO}.git" || true
          fi
          # 抓取 upstream 的 ref
          git fetch upstream "${UPSTREAM_REF}" --depth=1 || true
          # 尝试用 git show 导出文件（可以处理 Unicode 路径）
          if git ls-tree -r "upstream/${UPSTREAM_REF}" --name-only | grep -F -- "${UPSTREAM_PATH}" >/dev/null 2>&1; then
            git show "upstream/${UPSTREAM_REF}:${UPSTREAM_PATH}" > "${OUTFILE}" || true
          fi

          # 验证是否成功
          if [ ! -s "${OUTFILE}" ]; then
            echo "Failed to fetch upstream file from ${UPSTREAM_OWNER}/${UPSTREAM_REPO}/${UPSTREAM_REF}/${UPSTREAM_PATH}"
            exit 1
          fi

      - name: Compare and decide whether to update _worker.js
        run: |
          set -euo pipefail
          NEW="new_worker.js"
          DEST="_worker.js"

          # 如果目标文件存在且内容相同则退出（无更新）
          if [ -f "${DEST}" ] && cmp -s "${NEW}" "${DEST"; } 2>/dev/null || true; then
            if [ -f "${DEST}" ] && cmp -s "${NEW}" "${DEST}"; then
              echo "_worker.js is identical to upstream. No changes."
              exit 0
            fi
          fi

          # 用 new_worker.js 替换/创建 _worker.js
          mv "${NEW}" "${DEST}"
          echo "Replaced ${DEST} with upstream content."

      - name: Compute and update Version.txt
        run: |
          set -euo pipefail
          # 版本规则：major.minor，minor 每次 +1（代表 +0.1）
          # 如果没有 Version.txt，则根据 _worker.js 的历史提交次数来推断初始 minor（可解释为“已更新次数”）
          VERSION_FILE="Version.txt"

          # 读取现有版本
          if [ -f "${VERSION_FILE}" ]; then
            ver=$(cat "${VERSION_FILE}" | tr -d ' \t\r\n')
            if echo "${ver}" | grep -Eq '^[0-9]+\.[0-9]+$'; then
              major=$(echo "$ver" | cut -d. -f1)
              minor=$(echo "$ver" | cut -d. -f2)
            else
              major=1
              minor=0
            fi
          else
            # 如果没有 Version.txt，尝试根据 _worker.js 的历史提交次数来估算 minor：
            # 计数 = git log --follow -- _worker.js 的 commit 数（若为 N，则把更新次数设为 max(0, N-1)）
            if git rev-parse --verify HEAD >/dev/null 2>&1 && git ls-files --error-unmatch _worker.js >/dev/null 2>&1; then
              cnt=$(git --no-pager log --follow --pretty=oneline -- _worker.js | wc -l || true)
              if [ -z "$cnt" ] || [ "$cnt" -le 0 ]; then
                estimated_updates=0
              else
                estimated_updates=$((cnt - 1))
                if [ "$estimated_updates" -lt 0 ]; then estimated_updates=0; fi
              fi
            else
              estimated_updates=0
            fi
            major=1
            minor=${estimated_updates}
          fi

          # 这次运行视作一次更新：minor + 1
          minor=$((minor + 1))

          # 处理进位（minor >= 10 则进位到 major，并把 minor 置 0）
          if [ "${minor}" -ge 10 ]; then
            carry=$((minor / 10))
            minor=$((minor % 10))
            major=$((major + carry))
          fi

          newver="${major}.${minor}"
          echo "${newver}" > "${VERSION_FILE}"
          echo "Updated version -> ${newver}"

      - name: Commit and push changes
        env:
          GIT_COMMITTER_NAME: github-actions[bot]
          GIT_COMMITTER_EMAIL: github-actions[bot]@users.noreply.github.com
        run: |
          set -euo pipefail
          git config user.name "${GIT_COMMITTER_NAME}"
          git config user.email "${GIT_COMMITTER_EMAIL}"

          git add _worker.js Version.txt || true
          # 如果没有变更，直接退出
          if git diff --staged --quiet; then
            echo "No staged changes to commit."
            exit 0
          fi

          COMMIT_MSG="Update _worker.js and Version.txt"
          git commit -m "${COMMIT_MSG}"
          # push using the default checkout credential (GITHUB_TOKEN) provided by actions/checkout
          git push origin HEAD:main

      - name: Done
        run: echo "Update workflow finished."
